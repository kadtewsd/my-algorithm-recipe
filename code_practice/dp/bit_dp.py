# N = int(input())
from typing import List

# syain = input().splitlines()
# メンバー数が 6 の場合、入力される行数は 6 - 1 = 5 行になる。
# なぜなら、入力は「i < j を満たすペア (i, j) に対する幸福度」が与えられており、
# 最終行は (4, 5) の1組で終了する。
# よって、データ読み込み時のループは range(6 - 1) が正しい。

# ただし、後続のスコア計算では、メンバーの任意のペア (i, j) にアクセスするため、
# たとえば (5, 1) のように i > j となるケースも発生する。
# このとき、未初期化だと IndexError や不正なデータ参照につながる。

# したがって、幸福度を格納する二次元配列は、入力行数ではなく、
# メンバー数 N を用いた N × N 配列として初期化する必要がある。
syain = [
    "10 10 -10 -10 -10", #f0,1,f0,2,f0,3
    "10 -10 -10 -10", #f1,1,#f1,2,#f1,3,
    "-10 -10 -10", #f2,1,f2,2
    "10 -10", #f3,1
    "-10", #f4,1
]

M = 6
L = M - 1
#行数は 5 であるが、後続の処理でメンバーの数だけインデックスアクセスする必要がある。
#この際に、行数で初期化してしまうと、メンバーの数が行数を上まった際に例外が発生してしまう。
# 例 : 5 0。5,0 という 物に対応するために、L (= 行数) ではなく、M (メンバー数) でデータを構築する。
# 結構落とし穴
data = [[0] * M for _ in range(M)]
# data = [[0] * L for _ in range(L)]
# print(data)

for i in range(L):
    value = list(map(int, syain[i].split()))
    # print(value)
    for j, v in enumerate(value):
        # print(j)
        #i =1 の場合は、J は、2, 3, 4, 5。
        #つまり、j は 常に、i に対して + 1 の関係性を持つ必要がある。
        # value で enumerate しているので、6 (添え字 5) はこない。
        data[i][i + j + 1] = v
        data[i + j + 1][i] = v

# print(data[5][0])

# 組み合わせに対しての点数を構築する。0,1 は 10 といったようなデータ
# カラ集合を含めたすべての組み合わせに対しての点数を構築するために、score として構築
score = [0] * (1 << M)
# print(len(score))
for bit in range(1 << M):
    # 人数 M に対して M 個ビットずらし。bit を左にずらすと、10 進数の値が 2 乗されていく。
    # これが、選ぶ・選ばないの二通りに対しての乗数とマッチする。
    # たとえば、bit = 3 である場合、
    # 011 になる。0, 1 が選択されている状態になっている
    # これに対して、j が増えていく際に、
    # j = 0 = 0-> 00000 => MISS!
    # j = 1 = 1 => 00001 => HIT!
    # j = 2 = 2 => 00010 => HIT!
    # J = 3 = 4 => 00100 => HIT!
    # J = 4 = 16 => 01000 => MISS!
    # J = 5 = 32 => 10000 => MISS!
    members = [j for j in range(M) if bit & (1 << j)]
    # print(f"{bit} {members}")
    #member のすべての組み合わせで combination を構築する
    for i in range(len(members)):
        # いつ関係性としては fi12, f23 になるので、常に i + 1 が開始のループになる
        # このため、0,1 といった組み合わせになっていないものは除外される
        for j in range(i + 1, len(members)):
            # print(f"members {members[i]} {members[j]}")
            # print(f"{bit} {i} {j}")
            # print(f"{bit} {i} {j} {data[members[i]][members[j]]}")
            #メンバーに割り当てられている番号が、初期化にしたデータの番号に該当している
            # 例えば、f0,1
            score[bit] += data[members[i]][members[j]]

# print(score)
# グループの組み合わせの展開。111 を [100,010,001], [110,001] といったグループに分けてもっとも得点の高いグループを bit 添え字で記録
dp = [0] * (1 << M)
for bit in range(1 << M):
    # グループの組み合わせ。初回は全選択状態の bit。たとえば、3 であれば、011。つまり、2,1 のふたつとも同じグループになった状態
    # M = 6 である場合、この組み合わせはあり得ないが、後続のグループの展開によって必要になる
    sub = bit
    while sub:
        # 今のグループと、グループ分解したグループの得点比較。
        # 1111 であれば、排他的論理和により、dp[bit ^ sub] でこれまでにだしてきたグループの特典
        # dp[bit ^ sub] はそれ以前にグループの組み合わせが試行されており、値に
        #1. dp[000011] = score[000011]（社員0, 1 を1グループ）
        # 2. dp[001100] = score[001100]（社員2, 3 を1グループ）
        # 3. dp[110000] = score[110000]（社員4, 5 を1グループ）
        # そして順に、
        # 4. dp[001111] = dp[001100] + score[000011]
        # 5. dp[111111] = dp[001111] + score[110000]
        dp[bit] = max(dp[bit], dp[bit ^ sub] + score[sub] )
        # sub を -1 することで bit 演算する。誰もグループがいなくなるまでグループを分解する
        # 1111 (15) である場合は
        # 1110 (14) bit 1111 => 1110
        # 1101 (13) bit 1111 => 1101
        # 1100 (12) bit 1111 => 1100
        # 1011 (11) bit 1111 => 1011
        # 1010 (10) である。
        # sub 14 がセットされると、排他的論理和により
        # 1111 XOR 1110 => 0001 と sub == 1110 のスコアをセット (0001 は 14 であるので現在の 15 の前に算出済み) と グループ分割なしで比較
        # これによりグループ分割が勝手に進んでいく
        # print(sub)
        sub = bit & (sub - 1)
        # score[000011] → f12
        # score[001100] → f34
        # score[110000] → f56
        # 再帰して
        # dp[000011] = score[000011]
        # dp[001111] = dp[001100] + score[000011]
        # dp[111111] = dp[001111] + score[110000]


# 全選択状態の bit ( 1 << M。M = 6 であれば 111111 == 64) の配列が、最大の位置にいるので、表示
print(dp[(1 << M) - 1])

# sub = M
# while sub: